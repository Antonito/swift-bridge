use crate::extern_rust::ExternRustSection;

const NOTICE: &'static str = "// File automatically generated by swift-bridge.";
const INCLUDE_STDINT: &'static str = "#include <stdint.h>\n";

impl ExternRustSection {
    pub(crate) fn generate_c_header(&self) -> String {
        format!(
            r#"{notice}
{header}"#,
            notice = NOTICE,
            header = self.generate_c_header_inner()
        )
    }

    fn generate_c_header_inner(&self) -> String {
        let mut header = "".to_string();

        let mut contains_ints = false;

        for ty in self.types.iter() {
            let ty_name = ty.ty.ident.to_string();

            let ty_decl = format!("typedef struct {ty_name} {ty_name};", ty_name = ty_name);
            let drop_ty = format!(
                "void __swift_bridge__${ty_name}$_free(void* self);",
                ty_name = ty_name
            );

            header += &ty_decl;
            header += "\n";
            header += &drop_ty;
            header += "\n";

            for method in ty.methods.iter() {
                if !contains_ints {
                    contains_ints = method.func.contains_ints();
                }

                // FIXME: Normalize with code below
                let ret = method.func.to_c_header_return();
                let name = method.func.link_name(Some(&ty.ty.ident));
                let params = method.func.to_c_header_params();

                let declaration = format!(
                    "{ret} {name}({params});",
                    ret = ret,
                    name = name,
                    params = params
                );
                header += &declaration;
                header += "\n";
            }
        }

        for freestanding in self.freestanding_fns.iter() {
            // FIXME: Normalize with code above
            let ret = freestanding.to_c_header_return();
            let name = freestanding.link_name(None);
            let params = freestanding.to_c_header_params();

            if !contains_ints {
                contains_ints = freestanding.contains_ints();
            }

            let declaration = format!(
                "{ret} {name}({params});",
                ret = ret,
                name = name,
                params = params
            );
            header += &declaration;
            header += "\n";
        }

        if contains_ints {
            header = format!("{}{}", INCLUDE_STDINT, header);
        }

        header
    }
}

#[cfg(test)]
mod tests {
    use proc_macro2::TokenStream;
    use quote::quote;

    use crate::parse::SwiftBridgeModuleAndErrors;
    use crate::SwiftBridgeModule;

    use super::*;

    /// Verify that we generate an empty header file for an empty section.
    #[test]
    fn generates_empty_header_for_empty_section() {
        let section = ExternRustSection::default();

        let header = section.generate_c_header();

        assert_eq!(header.trim(), NOTICE)
    }

    /// Verify that we generate a type definition for a freestanding function that has no args.
    #[test]
    fn freestanding_function_no_args() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    fn foo();
                }
            }
        };
        let expected = r#"
void __swift_bridge__$foo(void);
        "#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    /// Verify that we generate a type definition for a freestanding function that has one arg.
    #[test]
    fn freestanding_function_one_args() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    fn foo(arg1: u8);
                }
            }
        };
        let expected = r#"
#include <stdint.h>
void __swift_bridge__$foo(uint8_t arg1);
        "#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    /// Verify that we generate a type definition for a freestanding function that returns a value.
    #[test]
    fn freestanding_function_with_return() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    fn foo() -> u8;
                }
            }
        };
        let expected = r#"
#include <stdint.h>
uint8_t __swift_bridge__$foo(void);
        "#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    /// Verify that we add a `typedef struct` for types in the extern "Rust" block.
    #[test]
    fn type_definition() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    type SomeType;
                }
            }
        };
        let expected = r#"
typedef struct SomeType SomeType;
void __swift_bridge__$SomeType$_free(void* self);
"#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    /// Verify that we generate a type definition for a method with no arguments.
    #[test]
    fn method_no_args() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    type SomeType;
                    fn a(self);
                    fn b(&self);
                    fn c(&mut self);
                    fn d(self: SomeType);
                    fn e(self: &SomeType);
                    fn f(self: &mut SomeType);
                }
            }
        };
        let expected = r#"
typedef struct SomeType SomeType;
void __swift_bridge__$SomeType$_free(void* self);
void __swift_bridge__$SomeType$a(void* self);
void __swift_bridge__$SomeType$b(void* self);
void __swift_bridge__$SomeType$c(void* self);
void __swift_bridge__$SomeType$d(void* self);
void __swift_bridge__$SomeType$e(void* self);
void __swift_bridge__$SomeType$f(void* self);
        "#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    /// Verify that we generate a type definition for a method with no arguments.
    #[test]
    fn method_one_arg() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    type SomeType;
                    fn foo(&self, val: u8);
                }
            }
        };
        let expected = r#"
#include <stdint.h>
typedef struct SomeType SomeType;
void __swift_bridge__$SomeType$_free(void* self);
void __swift_bridge__$SomeType$foo(void* self, uint8_t val);
        "#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    /// Verify that we generate a type definition for a method that has a return type.
    #[test]
    fn method_with_return() {
        let tokens = quote! {
            #[swift_bridge::bridge]
            mod ffi {
                extern "Rust" {
                    type SomeType;
                    fn foo(&self) -> u8;
                }
            }
        };
        let expected = r#"
#include <stdint.h>
typedef struct SomeType SomeType;
void __swift_bridge__$SomeType$_free(void* self);
uint8_t __swift_bridge__$SomeType$foo(void* self);
        "#;

        let module = parse_ok(tokens);
        assert_eq!(
            module.extern_rust[0].generate_c_header_inner().trim(),
            expected.trim()
        );
    }

    fn parse_ok(tokens: TokenStream) -> SwiftBridgeModule {
        let module_and_errors: SwiftBridgeModuleAndErrors = syn::parse2(tokens).unwrap();
        module_and_errors.module
    }
}
